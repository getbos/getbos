<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="/content/7e37766541506810ba6399c4b2735121f508bd9209df43dd200bf2316b014594i0"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
      }
      canvas {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
    </style>
    <meta charset="utf-8" />
  </head>
  <body>
    <script>
      //“Hyperbitcoinization is a voluntary transition from an inferior currency to a superior one, and its adoption is a series of individual acts of entrepreneurship rather than a single monopolist that games the system.” -Daniel Krawisz, Satoshi Nakamoto Institute
      //Thanks for stopping by ;) -Theezy
      let raylengths = [];
      let rayoffs = [];
      let raycols = [];
      let shootarray = [];
      let flarearray = [];
      let mainCanvas;

      let checkBlockInterval;

      let oldmouseX;
      let oldmouseX_count = 0;

      let starsx = [];
      let starsy = [];
      let starsw = [];
      let starscol = [];
      let sunholecols = [];
      let pulsewidths = [];
      let meteors = [];
      let pringscol = [];

      let wavearray = [];
      let autowave = 0;

      let bitcol;

      let dayscount = 0;

      let expected_add_blocks = 0;
      let todays_block;
      let current_block;

      let numholes;

      let dateang;

      let slidex_center;
      let slideon = 0;

      let realspeed = 1;
      let basetrip;
      let suntrip;
      let actsuntrip;

      let bitText;

      let loadflag = 1;

      const runes = [
        "ᚨ",
        "ᛒ",
        "ᚲ",
        "ᛞ",
        "ᛖ",
        "ᚠ",
        "ᚷ",
        "ᚺ",
        "ᛁ",
        "ᛃ",
        "ᚲ",
        "ᛚ",
        "ᛘ",
        "ᚾ",
        "ᚮ",
        "ᛈ",
        "ᚹ",
        "ᚱ",
        "ᛋ",
        "ᛏ",
        "ᚢ",
        "ᚡ",
        "ᚹ",
        "ᛪ",
        "ᚤ",
        "ᛉ",
      ];
      const romanSymbols = [
        "M",
        "CM",
        "D",
        "CD",
        "C",
        "XC",
        "L",
        "XL",
        "X",
        "IX",
        "V",
        "IV",
        "I",
      ];

      const roms = [
        "XII",
        "I",
        "II",
        "III",
        "IV",
        "V",
        "VI",
        "VII",
        "VIII",
        "IX",
        "X",
        "XI",
      ];
      const values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];

      //CONTROLS
      let sliderY;
      let knobX, knobY;
      let sliderHeight;
      let sliderWidth;
      let knobRadius;
      let sliderspeed = 1;
      let sliderActive = false;

      let lavaShader;

      let sunwrap;

      let pillb;
      let pillb2;

      let grainBuffer; // the graphics buffer to be layered onto the main canvas
      let grainShader; // the shader

      let scales = [];

      let frameimg;

      const vert = `
      // Determines how much precision the GPU uses when calculating floats
      precision highp float;

      // Get the position attribute of the geometry
      attribute vec3 aPosition;

      // Get the texture coordinate attribute from the geometry
      attribute vec2 aTexCoord;

      // The view matrix defines attributes about the camera, such as focal length and camera position
      // Multiplying uModelViewMatrix * vec4(aPosition, 1.0) would move the object into its world position in front of the camera
      uniform mat4 uModelViewMatrix;

      // uProjectionMatrix is used to convert the 3d world coordinates into screen coordinates
      uniform mat4 uProjectionMatrix;

      varying vec2 vVertTexCoord;

      void main(void) {
        vec4 positionVec4 = vec4(aPosition, 1.0);
        gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
        vVertTexCoord = aTexCoord;
      }
      `;
      const frag = `
      precision highp float;
      varying vec2 vVertTexCoord;

      uniform sampler2D source;
      uniform float noiseSeed;
      uniform float noiseAmount;

      // Noise functions
      // https://github.com/patriciogonzalezvivo/lygia/blob/main/generative/random.glsl
      float rand(vec2 n) { 
          return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
      }

      void main() {
          // GorillaSun's grain algorithm
          vec4 inColor = texture2D(source, vVertTexCoord);
          gl_FragColor = clamp(inColor + vec4(
              mix(-noiseAmount, noiseAmount, fract(noiseSeed + rand(vVertTexCoord * 1234.5678))),
              mix(-noiseAmount, noiseAmount, fract(noiseSeed + rand(vVertTexCoord * 876.54321))),
              mix(-noiseAmount, noiseAmount, fract(noiseSeed + rand(vVertTexCoord * 3214.5678))),
              0.
          ), 0., 1.);
      }
      `;
      //"HYPERBITCOINIZATION" BY THEEZY

      function setup() {
        randomSeed(21000000);
        ww = wh = min(windowWidth, windowHeight);

        mainCanvas = createCanvas(ww, wh);

        frameRate(38);
        createCanvas(ww, wh);
        pixelDensity(1.67);
        pixelDensity(2);

        bitcol = color(235, 200, 0, 255);
        //bitcol = color(200, 167, 0, 255);

        //bitcol = color(255, 215, 0, 255);

        // bitcol = color(200, 165, 0, 255);
        //bitcol = color(215,195,0);
        // shaders can only be used in WEBGL mode
        grainBuffer = createGraphics(width, height, WEBGL);

        grainShader = grainBuffer.createShader(vert, frag);

        todays_block = loadStrings("/blockheight");
        current_block = todays_block;

        sliderHeight = 0.1 * height;
        sliderWidth = 0.1 * width;
        knobRadius = 0.2 * sliderHeight;
        knobX = width / 2;

        //BACKGROUND
        bgcol = color(0);
        background(bgcol);

        clear();

        //SOL SETUP
        numrays = 333;
        raydeg = 360 / numrays;
        //solcols = [color(255, 100, 100), color(255, 255, 200), color(255, 155, 55)];
        solcols = [
          color(255, 255, 235),
          color(255, 255, 200),
          color(255, 255, 255),
        ];

        rayw = 0.0014 * width;
        //rayw = 0.001*width;
        //rayw = 0.00075*width;

        numholes = 14;

        for (h = 0; h < numholes; h++) {
          rc = random(155, 255);
          gc = random() * rc;
          bc = random() * gc;
          holecol = random(255);
          // holecol = color(rc, gc, bc);
          sunholecols.push(color(holecol));
        }

        //ORBIT SPEED
        suntrip = 0.0014;
        //suntrip = 0.005;
        basetrip = suntrip;

        //IMAGE BG
        //COLOR BG CLOUDS NOVA
        cloudstrait = true;
        numclouds = 350;
        noStroke();
        if (cloudstrait == true) {
          for (g = 0; g < numclouds; g++) {
            ex = random(width);
            ey = random(height);

            cscale = dist(ex, ey, width / 2, height / 2) / (width / 2);

            if (cscale > 0.58) {
              fill(0, 0);
              if (g < numclouds / 7) {
                fill(color(50, random(0, 255), random(155, 255), 1));
              }
              //fill(color(0, 0));
            } else {
              fill(color(random(155, 255), random(55, 200), 0, 3));
            }

            //cc = random(255);
            ellipse(ex, ey, random(0.1, 0.4) * width);
          }
        }

        numclouds = 85;
        for (g = 0; g < numclouds; g++) {
          fill(color(random(255), random(55), random(155, 255), 2));
          //fill(225, 225, 255,2);
          fill(255, 2);
          cc = random(255);

          ellipse(random(width), random(height), random(0.1, 0.5) * width);
        }

        //STARS
        starimg = createGraphics(1.5 * width, 1.5 * height);
        numstars = 2000;

        //starimg.background(255);
        for (s = 0; s < numstars; s++) {
          starimg.fill(255, random(100, 200));
          //starimg.fill(255);
          starimg.noStroke();
          starimg.ellipse(
            random(starimg.width),
            random(starimg.height),
            random(0.00067 * width, 0.0025 * width)
          );
        }

        //DARKEN BG CENTER
        noStroke();
        fill(45, 125);
        ellipse(width / 2, height / 2, 0.5 * width);

        //GLOW SHELL
        stroke(255, 255, 215, 200);
        noFill();
        ellipse(width / 2, height / 2, 0.33 * width);

        //GLOW SHELL

        noFill();

        stroke(255, 75, 255, 155);
        stroke(255, 85, 85, 215);
        // stroke(255, 215);

        //stroke(85, 85, 255);
        //stroke(255, 200, 100, 185);

        ellipse(width / 2, height / 2, 0.45 * width);

        //RINGS
        strokeWeight(0.001 * width);
        stroke(255, 255, 215, 75);
        nume = 20;
        for (e = 0; e < nume; e++) {
          ecol = lerpColor(color(255, 185), color(255, 255, 225, 15), e / nume);

          stroke(ecol);
          ellipse(width / 2, height / 2, 0.33 * width + 0.01 * e * width);
        }

        stroke(255, 185);
        ellipse(width / 2, height / 2, 0.5 * width);

        stroke(255, 155, 55, 185);
        ellipse(width / 2, height / 2, 0.975 * width);

        stroke(255, 120);
        coordwidth = 0.89 * width;
        ellipse(width / 2, height / 2, coordwidth);
        ellipse(width / 2, height / 2, coordwidth + 0.075 * width);

        let lineLength = 0.015 * coordwidth;
        strokeWeight(0.005 * width);
        //COORD LINES
        strokeCap(SQUARE);
        for (let i = 0; i < 12; i++) {
          let angle = (TWO_PI / 12) * i;
          let startX = width / 2 + (coordwidth / 2) * cos(angle);
          let startY = height / 2 + (coordwidth / 2) * sin(angle);
          let endX = width / 2 + (coordwidth / 2 - lineLength) * cos(angle);
          let endY = height / 2 + (coordwidth / 2 - lineLength) * sin(angle);

          line(startX, startY, endX, endY);
        }

        //RUNES

        months = [
          "JAN",
          "FEB",
          "MAR",
          "APR",
          "MAY",
          "JUN",
          "JUL",
          "AUG",
          "SEP",
          "OCT",
          "NOV",
          "DEC",
        ];

        push();
        noStroke();
        translate(width / 2, height / 2);
        textSize(0.015 * width);
        textAlign(CENTER, CENTER);
        fill(255, 55);
        numrunes = 36;
        numrunes = 60;
        for (let i = 0; i < numrunes; i++) {
          fill(255, 255, 245, 225);
          textSize(0.01 * width);
          runet = random(runes);

          if (i % 5 == 0) {
            fill(255, 225);
            textSize(0.023 * width);
            runet = runes[floor(i / 3) + 1];
          }

          text(runet, 0, -0.4 * height);
          rotate(radians(360 / numrunes));
        }
        pop();

        strokeWeight(0.001 * width);
        lineLength = 1 * coordwidth;
        for (let i = 0; i < 12; i++) {
          let angle = (TWO_PI / 12) * i;
          let startX = width / 2 + (coordwidth / 2) * cos(angle);
          let startY = height / 2 + (coordwidth / 2) * sin(angle);
          let endX = width / 2 + (coordwidth / 2 - lineLength) * cos(angle);
          let endY = height / 2 + (coordwidth / 2 - lineLength) * sin(angle);
        }

        lineLength = 0.01 * coordwidth;
        for (let i = 0; i < 365; i++) {
          let angle = (TWO_PI / 365) * i;
          let startX = width / 2 + (coordwidth / 2) * cos(angle);
          let startY = height / 2 + (coordwidth / 2) * sin(angle);
          let endX = width / 2 + (coordwidth / 2 - lineLength) * cos(angle);
          let endY = height / 2 + (coordwidth / 2 - lineLength) * sin(angle);

          line(startX, startY, endX, endY);
        }

        //SPIRAL
        push();
        translate(width / 2, height / 2);
        stroke(255, 35);
        stroke(85, 255, 155, 100);
        stroke(255, 255, 235, 55);
        //stroke(255, 185, 100, 65);
        for (d = 0; d < 265; d++) {
          rotate(d / 365);
          line(width / 2, 0, width / 2, height);
        }
        pop();

        applyGrain();

        numstars = 0;
        for (s = 0; s < numstars; s++) {
          starsx.push(random(width));
          starsy.push(random(height));
          starsw.push(random(0.001 * width, 0.005 * width));
          starscol.push(random(55, 200));
        }

        bgimg = get();

        //SET RAYS
        for (r = 0; r < numrays; r++) {
          rlen = random(0.15, 0.435) * width;

          scol = random(solcols);
          scol = random(100, 255);

          rc = random(100, 255);
          ia = random(0.75, 1);
          scol = color(rc, rc, rc * ia, random(155, 255));

          raylengths.push(rlen);

          rayoffs.push(random(100));

          scol = color(random(155, 255));
          //scol = color(random(255), random(255), random(255));
          scol2 = color(red(scol), green(scol), blue(scol), random(255, 255));
          scol2 = color(red(scol), green(scol), blue(scol), random(55, 255));
          //scol2 = random(155, 255);
          raycols.push(scol2);
        }

        //BITCOIN TEXTURE
        bitText = createGraphics(0.2 * width, 0.2 * height);
        bitText.background(bitcol); // Yellow background
        bitText.clear();
        bitText.fill(200, 115, 0); // Black text
        bitText.fill(215);
        bitText.stroke(0);
        bitText.strokeWeight(0.045 * bitText.width);
        bitText.textAlign(CENTER, CENTER);
        bitText.textSize(0.2 * width);
        bitText.textFont("Courier New");
        bitText.textStyle(BOLD);
        bitText.text("₿", bitText.width * 0.525, bitText.height * 0.6); // Draw "B" at the center

        //ORANGE PILL TEXTURE
        pillb = createGraphics(0.2 * width, 0.2 * height);
        pillb.background(255, 155, 0); // Yellow background
        //bitText.clear();
        pillb.fill(0);
        pillb.noStroke();
        pillb.strokeWeight(0.045 * pillb.width);
        pillb.textAlign(CENTER, CENTER);
        pillb.textSize(0.25 * pillb.width);
        pillb.textFont("Courier New");
        pillb.textStyle(BOLD);
        //pillb.text('₿', pillb.width*0.525, pillb.height*0.6); // Draw "B" at the center
        //pillb.text('₿', pillb.width*0.525, pillb.height*0.1); // Draw "B" at the center
        pillb.translate(pillb.width * 0.25, pillb.height * 0.1);
        pillb.rotate(radians(90));
        pillb.text("₿", 0.1 * pillb.width, 0); // Draw "B" at the center
        pillb.textSize(0.067 * pillb.width);
        //pillb2.translate(-0.2*pillb2.width, 1.1*pillb2.height);
        pillb.rotate(radians(180));
        pillb.translate(-0.1 * pillb.width, 0.5 * pillb.height);
        //pillb.rotate(radians(90));

        pillb.text("21 mil", 0, 0); // Draw "B" at the center

        //IVORY PILL TEXTURE
        pillb2col = color(255, 255, 235);
        pillb2 = createGraphics(0.2 * width, 0.1 * height);
        pillb2.background(pillb2col); // Yellow background
        //bitText.clear();
        pillb2.fill(0);
        pillb2.noStroke();
        pillb2.strokeWeight(0.045 * pillb.width);
        pillb2.textAlign(CENTER, CENTER);
        pillb2.textSize(0.25 * pillb.width);
        pillb2.textFont("Courier New");
        pillb2.textStyle(BOLD);
        //pillb.text('₿', pillb.width*0.525, pillb.height*0.6); // Draw "B" at the center
        //pillb.text('₿', pillb.width*0.525, pillb.height*0.1); // Draw "B" at the center
        pillb2.translate(pillb.width * 0.25, pillb.height * 0.1);
        pillb2.rotate(radians(90));
        pillb2.text("₿", 0.1 * pillb2.width, 0); // Draw "B" at the center
        pillb2.textSize(0.067 * pillb2.width);
        //pillb2.translate(-0.2*pillb2.width, 1.1*pillb2.height);
        pillb2.rotate(radians(180));
        pillb2.translate(-0.1 * pillb2.width, 1 * pillb2.height);
        //pillb2.rotate(radians(90));

        pillb2.text("21 mil", 0, 0); // Draw "B" at the center

        //EARTH TEXTURE
        earthg = createGraphics(width / 4, height / 4);
        earthg.background(color(55, 125, 225));

        numconts = 23;
        earthg.noStroke();
        earthg.fill(color(55, 255, 100));
        for (land = 0; land < numconts; land++) {
          earthg.ellipse(
            random(earthg.width),
            random(earthg.height),
            random(earthg.width * 0.02, earthg.width * 0.15)
          );
        }

        //TIME TEXTURE
        dateimg = createGraphics(0.22 * width, 0.11 * height);

        //DATE STARTING ANGLE
        let now = new Date(); // Get the current date
        let startOfYear = new Date(now.getFullYear(), 0, 1); // Get January 1st of this year
        let endOfYear = new Date(now.getFullYear() + 1, 0, 1); // Get January 1st of next year

        // Calculate the proportion of the year that has passed
        let propyear = (now - startOfYear) / (endOfYear - startOfYear);
        dateang = radians(propyear * 360 - 90);

        fw = 0.025 * width;

        //SET UP SLIDER CONTROL
        sliderY = height + sliderHeight; // Start off-screen
        // knobX = width / 2;
        knobY = sliderY + sliderHeight / 2;

        noLoop();
        createCanvas(width, height, WEBGL);

        if (width > 500) {
          loop();
          loadflag = 0;
        }
        //noLoop();
        checkBlockInterval = setInterval(checkblock, 100);

        spheregraphics = createGraphics(width, height, WEBGL);
      }

      function draw() {
        clear();

        //Update Block once in a while
        if (frameCount % 100000 == 0) {
          current_block = loadStrings("/blockheight");
          console.log("check");
        }

        orbosc = (sin(frameCount * 0.03) + 1) / 2;

        baseosc = sin(frameCount * 0.025);

        if (random() < 0.15) {
          ss = new shootingstar();
          shootarray.push(ss);
        }

        //BACKGROUUND
        push();
        imageMode(CENTER);
        background(bgcol);

        rotate(-frameCount * 0.0002);

        image(starimg, 0, 0, starimg.width, starimg.height);
        pop();

        texture(bgimg);
        plane(width);

        translate(-width / 2, -height / 2);

        sunandrings();

        //CLOCK
        push();

        pointLight(255, 255, 255, 0, 0, 0);
        pointLight(200, 200, 200, 0, 0, 0);

        //CLOCK HANDS
        let h = hour();
        let m = minute();
        let s1 = second();
        let now = new Date();
        let milli = now.getMilliseconds();
        let sec = s1 + milli / 1000;

        //let hour
        console.log(m);
        // Calculate continuous angles for the dots
        let secondAngle = radians(map(sec, 0, 60, 0, 360));
        let minuteAngle = radians(map(m * 60 + sec, 0, 3600, 0, 360)); // Continuous movement for minutes
        let hourAngle = radians(
          map((h % 12) * 3600 + m * 60 + sec, 0, 43200, 0, 360)
        ); // Continuous movement for hours
        let halvingAngle = ((current_block % 210000) / 210000) * 360;

        let hourw = 0.009 * width;

        // Draw the clock face
        noFill();

        // Draw the hour dot
        push();
        translate(width / 2, height / 2);
        rotate(hourAngle);

        noStroke();
        fill(255, 225, 0, 185);
        translate(0, -0.423 * width);
        sphere(hourw);
        pop();

        // Draw the minute dot
        push();
        translate(width / 2, height / 2);
        rotate(minuteAngle);
        fill(0, 255, 100, 185);
        noStroke();
        translate(0, -0.423 * width);
        sphere(0.67 * hourw);
        pop();

        // Draw the second dot
        push();
        translate(width / 2, height / 2);
        rotate(secondAngle);
        fill(255, 85, 85, 185); // Red color for the second dot
        noStroke();
        //ellipse(0, -0.423*width, 0.0075*width);
        translate(0, -0.423 * width);
        sphere(0.8 * hourw);
        pop();

        // Draw the halving mark
        push();
        translate(width / 2, height / 2);
        rotate(radians(halvingAngle));
        fill(255, 155, 55, 185);
        //fill(255, 155, 0, 185);
        noStroke();
        //ellipse(0, -0.423*width, 0.01*width);
        translate(0, -0.423 * width);
        sphere(0.67 * hourw);
        pointLight(color(200), 0, 0, width);
        numrings = 5;
        rwidth = (0.5 * hourw) / numrings;
        for (r = 0; r < numrings; r++) {
          fill(255, 155);
          torus(1 * hourw + rwidth * 1.3 * r, rwidth / 2, 64, 64);
        }
        pop();

        pop();
        //END CLOCK

        if (sliderActive) {
          realspeed = 100;
        } else {
          realspeed = 1;
        }

        suntrip = basetrip * realspeed;
        earthspin = suntrip * 365.2421988;

        push();

        translate(width / 2, height / 2);
        rotateZ(dateang + frameCount * suntrip);
        translate(-width / 2, -height / 2);
        translate(0.965 * width, height / 2);

        pointLight(color(255), 0, 0, 0);
        pointLight(color(255), 0, 0, 0);

        rotateZ(frameCount * earthspin);
        // rotateX(frameCount*0.0025);
        noStroke();
        fill(color(55, 125, 225));
        texture(earthg);

        push();
        rotateX(frameCount * 0.15 * earthspin);
        sphere(0.015 * width);
        pop();

        fill(color(155, 155, 255, 35));
        sphere(0.0285 * width);
        //moon
        rotate(-frameCount * 0.96 * earthspin);
        translate(0.0375 * width, 0);
        fill(200);
        sphere(0.0035 * width);

        pop();

        //BLOCKS PER DAY
        let framesForFullRotation = TWO_PI / earthspin;

        expected_add_blocks = round(144 * (frameCount / framesForFullRotation));

        dayscount = round(frameCount / framesForFullRotation);

        // fw = 0.025*width;
        // fw = 0.08*width;

        //fw = 0.04*width;
        //fw = 0.075*width;
        //DATE
        dateimg.background(0, 0);
        dateimg.clear();
        dateimg.textSize(0.085 * dateimg.width);
        dateimg.textFont("Courier New");
        dateimg.textStyle(BOLD);

        dateimg.fill(color(255, 145, 75, 215));

        tx = -width / 2 + fw * 2;
        ty = height / 2 - fw * 2 - dateimg.height;

        dateimg.textAlign(RIGHT, BOTTOM);
        datespin = dayCountToDate(dayscount);
        //dateimg.text(`${datespin}`, dateimg.width-fw, dateimg.height-fw);
        dateimg.text(`${datespin}`, dateimg.width - fw, dateimg.height / 2);

        expected_block = int(todays_block[0]) + expected_add_blocks;
        if (todays_block[0] == undefined) {
          expected_block = "";
        }
        dateimg.text(
          `${expected_block}`,
          dateimg.width - fw,
          dateimg.height - 1.2 * fw
        );

        noStroke();

        texture(dateimg);
        rect(
          width - dateimg.width,
          height - dateimg.height,
          dateimg.width,
          dateimg.height
        );

        //REUSE FOR HALVINGS
        //NUMBER HALVINGS LEFT
        halvings_completed = floor(expected_block / 210000);
        numleft = 32 - halvings_completed;
        if (numleft > 0) {
          romleft = convertToRoman(numleft);
        } else {
          romleft = "0";
        }

        dateimg.clear();
        dateimg.textAlign(LEFT, BOTTOM);
        dateimg.fill(color(0, 255, 55, 215));

        dateimg.fill(color(255, 100, 55, ((baseosc + 1) / 2) * 155 + 100));
        dateimg.fill(color(255, 185, 255, ((baseosc + 1) / 2) * 155 + 100));
        dateimg.fill(color(235, ((baseosc + 1) / 2) * 100 + 100));

        dateimg.fill(color(0, 255, 55, 215));
        dateimg.text(`${romleft}`, fw, dateimg.height - 1.2 * fw);

        texture(dateimg);
        rect(0, height - dateimg.height, dateimg.width, dateimg.height);

        //orbSlider();

        noCursor();

        fadenum = 55;
        if (
          mouseX > 0 &&
          mouseX < width &&
          mouseY > 0 &&
          mouseY < height &&
          oldmouseX_count < fadenum
        ) {
          //if(dist(mouseX, mouseY, width/2, height/2) < 0.4*width){
          push();
          rectMode(CENTER);
          shootboxw = 0.03 * width;
          fill(0, 55);
          stroke(255, 0, 0, 175);
          stroke(0, 255, 0, 175);

          if (oldmouseX_count > fadenum / 2) {
            stroke(
              0,
              255,
              0,
              175 * (1 - (oldmouseX_count - fadenum / 2) / fadenum)
            );
          }
          strokeWeight(0.002 * width);
          rect(mouseX, mouseY, shootboxw);
          ellipse(mouseX, mouseY, shootboxw / 2);
          line(mouseX - shootboxw / 2, mouseY, mouseX + shootboxw / 2, mouseY);
          line(mouseX, mouseY - shootboxw / 2, mouseX, mouseY + shootboxw / 2);

          pop();
        }

        if (mouseX == oldmouseX) {
          oldmouseX_count++;
        } else {
          oldmouseX_count = 0;
        }
        oldmouseX = mouseX;

        push();
        translate(width / 2, height / 2);
        rotateY(radians(9 + frameCount / 2));
        //   //SPHERE CAGE
        push();
        cylw = 0.08 * width;

        stroke(255, abs(rayosc) * 200 + 55);
        strokeWeight(0.00185 * width);
        noFill();
        sphere(1.5 * cylw, 20, 15);

        pop();

        pop();

        push();
        pointLight(255, 255, 255, 0, 0, 0);
        graphics_sphere();
        image(spheregraphics, 0, 0, width, height);
        pop();

        //SHOCKWAVES INTERACTION
        if (autowave == 1 && frameCount % 5 == 0) {
          wave = new shockwave(mouseX, mouseY);
          wavearray.push(wave);
        }
        for (s = 0; s < wavearray.length; s++) {
          wavearray[s].display();

          if (wavearray[s].isOutsideBoundary()) {
            wavearray.splice(s, 1);
          }
        }

        //FRAME
        push();
        strokeWeight(fw);
        noFill();
        stroke(255, 200, 125);

        rect(0, 0, width, height);
        strokeWeight(0.67 * fw);
        stroke(10);
        stroke(255, 255, 235);
        stroke(55, 55, 40);
        stroke(35, 35, 20);

        //stroke(35, 55, 105);

        rect(0, 0, width, height);
        pop();
      }

      function graphics_sphere() {
        //SPINNING COIN
        spheregraphics.clear();
        spheregraphics.push();

        spheregraphics.noFill();
        spheregraphics.strokeWeight(0.0015 * width);
        spheregraphics.stroke(color(235, 235, 200));

        spheregraphics.push();

        spheregraphics.pointLight(color(100), 0, 0, width);

        spheregraphics.pointLight(255, 255, 255, 0, 0, width);

        spheregraphics.noStroke();
        spheregraphics.fill(bitcol);

        cylw = 0.08 * width;
        cylh = 0.2 * cylw;

        cylw = 0.85 * cylw;
        cylh = 0.85 * cylh;

        spheregraphics.rotateX(radians(90));

        spheregraphics.rotateY(radians(180));
        spheregraphics.rotateZ(radians(90) + frameCount * 0.01);

        //ORANGE PILL
        pillw = cylh * 2.2;
        pillh = cylw * 2;
        spheregraphics.push();
        spheregraphics.fill(255, 155, 0);
        spheregraphics.texture(pillb);
        spheregraphics.rotateX(radians(baseosc * 15));
        spheregraphics.cylinder(pillw, pillh);

        spheregraphics.push();
        spheregraphics.fill(255, 155, 0);
        spheregraphics.translate(0, -pillh / 2, 0);
        spheregraphics.sphere(pillw);

        spheregraphics.fill(255, 255, 235, 100);
        spheregraphics.translate(0, 0.75 * pillh, 0);

        spheregraphics.fill(255, 255, 235, 255);
        spheregraphics.push();
        spheregraphics.rotateZ(radians(180));
        spheregraphics.texture(pillb2);
        spheregraphics.cylinder(1.01 * pillw, 0.5 * pillh);
        spheregraphics.pop();

        spheregraphics.translate(0, 0.25 * pillh, 0);
        spheregraphics.fill(pillb2col);
        spheregraphics.sphere(1.01 * pillw);
        spheregraphics.pop();

        spheregraphics.pop();

        spheregraphics.pop();

        spheregraphics.pop();
      }

      function sunandrings() {
        cx = width / 2;
        cy = height / 2;

        push();
        translate(cx, cy);

        for (s = 0; s < shootarray.length; s++) {
          shootarray[s].display();

          if (shootarray[s].isOutsideBoundary()) {
            shootarray.splice(s, 1);
          }
        }

        for (f = 0; f < flarearray.length; f++) {
          flarearray[f].display();

          if (flarearray[f].isOutsideBoundary()) {
            flarearray.splice(f, 1);
          }
        }

        push();
        strokeWeight(rayw);
        //ELLIPSE GROW

        noFill();

        erat = floor(frameCount / 3) % 26;
        egrow = erat * 0.02 * width;
        eratio = erat / 26;
        stroke(255, 255 - eratio * 255);

        ellipse(0, 0, egrow, egrow, 50);

        pop();

        strokeWeight(rayw);

        for (r = 0; r < raylengths.length; r++) {
          rayosc = sin((frameCount + rayoffs[r]) * 0.025);

          scol2 = raycols[r];

          stroke(scol2);

          rlen = raylengths[r] * rayosc;

          rotate(radians(raydeg));
          line(0, 0, rlen, 0);
        }

        fill(255, 255, 235);
        fill(0);

        ellipse(0, 0, 0.24 * width);

        fill(255);
        ellipse(0, 0, 0.24 * width);

        push();

        fill(0);
        noFill();
        strokeWeight(0.0015 * width);
        stroke(color(255, 255, 235));
        stroke(color(235, 235, 200));
        rotateZ(radians(360 / 12));
        rotateY(radians(frameCount / 2));
        rotateX(radians(45));

        pop();

        //INNER SOL

        noStroke();
        fill(255, 155, 100, 200);
        fill(255, 155, 100, 155);

        //SMALL INNER
        fill(255, 55, 0, 255);
        fill(255, 0, 0, 255);

        noStroke();
        fill(255, 100, 55, 155);

        fill(185, 185);

        pop();

        //BLACKHOLE
        noStroke();
        fill(0, 10);
        for (b = 0; b < numholes; b++) {
          ellipse(width / 2, height / 2, 0.25 * width + b * 0.005 * width);
        }

        //GLOW
        fill(0, 85);
        ellipse(width / 2, height / 2, 0.33 * width);

        noStroke();
        fill(255, 255, 255, 15);

        for (b = 0; b < numholes; b++) {
          ellipse(width / 2, height / 2, 0.24 * width + b * 0.0085 * width);
        }

        //DULL BG BRIGHTNESS A BIT
        fill(155, 200);
        ellipse(width / 2, height / 2, 0.24 * width);

        fill(255, 100, 55, 255);
        fill(185);
        ellipse(width / 2, height / 2, 0.24 * width);
        //INNER FLAME
        for (b = 0; b < numholes; b++) {
          rayosc = (sin((frameCount + 25 * b) * 0.025) + 1) / 2;

          flamecol = color(
            red(sunholecols[b]),
            green(sunholecols[b]),
            blue(sunholecols[b]),
            rayosc * 155
          );

          fill(flamecol);
          ellipse(width / 2, height / 2, 0.24 * width * rayosc);
        }

        //BRIGHT INNER AURA
        numsuns = 8;
        for (se = 0; se < numsuns; se++) {
          rayosc = sin((frameCount + rayoffs[se]) * 0.025);
          fill(255, 255, 255, 10);
          rayosc = sin((frameCount + se * 20) * 0.025);
          fill(255, 255, 255, 15);
          acol = sunholecols[se % sunholecols.length];
          ellipse(width / 2, height / 2, 0.24 * width * rayosc);
        }

        //OUTER AURA
        for (se = 0; se < 8; se++) {
          rayosc = sin((frameCount + rayoffs[se]) * 0.025);
          fill(225, 3);

          ellipse(width / 2, height / 2, 0.4 * width * rayosc);
        }

        noFill();
        noStroke();
      }

      function convertToRoman(num) {
        // Define the Roman numeral symbols and their corresponding values

        let romanNumeral = ""; // Initialize the result string

        // Loop through the values and construct the Roman numeral
        for (let i = 0; i < values.length; i++) {
          while (num >= values[i]) {
            romanNumeral += romanSymbols[i];
            num -= values[i];
          }
        }

        return romanNumeral;
      }

      function dayCountToDate(daysCount) {
        //const startDate = new Date('2024-01-01'); // Start from January 1st, 2024
        const startDate = new Date();

        startDate.setDate(startDate.getDate() + daysCount); // Subtract 1 because day count starts from 1
        const month = startDate.toLocaleString("default", { month: "short" }); // Get abbreviated month name
        const day = startDate.getDate().toString().padStart(2, "0"); // Ensure day is two digits
        const year = startDate.getFullYear(); // Get the year
        return `${month} ${day} ${year}`;
      }
      class meteor {
        constructor(x, y) {
          let d = 1.5 * width;
          // Calculate the x and y coordinates using the angle and distance
          this.x = x;
          this.y = y;

          if (x != "NA") {
            this.x = mouseX;
            this.y = mouseY;
          }

          this.w = 0.003 * width;

          this.vx = (0 - this.x) * 0.01; // + random(-0.1*width, 0.1*width);
          this.vy = (0 - this.y) * 0.01; // + random(-0.1*height, 0.1*height);
          this.col = color(255, random(155, 225));
        }

        display() {
          push();
          translate(this.x, this.y);
          pop();
        }
      }

      class shootingstar {
        constructor(x = "NA", y = "NA") {
          let angle = random() * 2 * Math.PI;

          let d = 1.5 * width;
          // Calculate the x and y coordinates using the angle and distance
          this.x = width / 2 + d * cos(angle);
          this.y = height / 2 + d * sin(angle);

          if (x != "NA") {
            this.x = mouseX;
            this.y = mouseY;
          }

          this.w = 0.003 * width;

          this.vx = (0 - this.x) * 0.01; // + random(-0.1*width, 0.1*width);
          this.vy = (0 - this.y) * 0.01; // + random(-0.1*height, 0.1*height);
          this.col = color(255, random(155, 225));
        }

        display() {
          noStroke();
          fill(this.col);
          ellipse(this.x, this.y, this.w);

          let tlen = 30;
          for (let t = 0; t < tlen; t++) {
            ellipse(
              this.x - this.vx * t * 0.5,
              this.y - this.vy * t * 0.5,
              this.w - (t / tlen) * this.w
            );
          }

          this.x += this.vx;
          this.y += this.vy;
        }

        isOutsideBoundary() {
          let bound = 1.5 * width;
          // bound = 0.01*width
          return (
            this.x < -bound ||
            this.x > bound ||
            this.y < -bound ||
            this.y > bound
          );
          //return dist(this.x, this.y, 0, 0) < 0.04*width;
          //return this.x > -bound && this.x < bound && this.y > -bound && this.y < bound;
        }
      }

      function mousePressed() {
        loop();

        wave = new shockwave(mouseX, mouseY);
        wavearray.push(wave);

        autowave = 1;
      }

      function mouseReleased() {
        autowave = 0;
      }

      class shockwave {
        constructor(x, y) {
          this.x = x;
          this.y = y;

          this.w = 0;
        }

        display() {
          push();
          noFill();
          strokeWeight(0.003 * width);
          stroke(color(235, 255, 255, 100 - (this.w / width) * 300));
          //stroke(color(255, 240, 255, 175 - (this.w/width)*400));

          //stroke(255);
          //fill(240, 255, 255, 3 - (this.w/width)*6);
          ellipse(this.x, this.y, this.w, this.w, 50);
          pop();

          this.w += 0.003 * width;
        }

        isOutsideBoundary() {
          let bound = 0.67 * width;
          return this.w > bound;
        }
      }

      async function checkblock() {
        //console.log("tex");
        if (loadflag == 1 && todays_block[0] != undefined) {
          redraw();
          clearInterval(checkBlockInterval);
          randomSeed(todays_block[0]);
        }
      }

      function granulate(amount) {
        loadPixels();
        const d = pixelDensity();
        const pixelsCount = 4 * (width * d) * (height * d);
        for (let i = 0; i < pixelsCount; i += 4) {
          const grainAmount = random(-amount, amount);
          pixels[i] = pixels[i] + grainAmount;
          pixels[i + 1] = pixels[i + 1] + grainAmount;
          pixels[i + 2] = pixels[i + 2] + grainAmount;
        }
        updatePixels();
      }

      function applyGrain() {
        grainBuffer.clear();
        grainBuffer.reset();
        grainBuffer.push();
        grainBuffer.shader(grainShader);
        grainShader.setUniform("source", mainCanvas);

        grainShader.setUniform("noiseAmount", 0.085);
        grainBuffer.rectMode(CENTER);
        grainBuffer.noStroke();
        grainBuffer.rect(0, 0, width, height);
        grainBuffer.pop();

        clear();
        push();
        image(grainBuffer, 0, 0);
        pop();
      }
    </script>
  </body>
</html>
